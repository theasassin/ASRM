#load dada2
library (dada2)

#set the correct path
path <- "validated_trimmed_samples"

#set working directory PCOS_Rhesus_Sassin

#verify the correct path is set 
list.files(path)

# Forward and reverse fastq filenames have format: SAMPLENAME_R1_001.fastq (Aagaard.91.30435.Oral-read_R1_val_1.fq.gz) and SAMPLENAME_R2_001.fastq (Aagaard.91.30435.Oral-read_R2_val_2.fq.gz) 
fnFs <- sort(list.files(path, pattern="_R1_val_1.fq.gz", full.names = TRUE))
fnRs <- sort(list.files(path, pattern="_R2_val_2.fq.gz", full.names = TRUE))

# Extract sample names, assuming filenames have format: SAMPLENAME_XXX.fastq
sample.names <- sapply(strsplit(basename(fnFs), "_"), `[`, 1)

#Run the Plot Quality of the reverse reads for four samples
plotQualityProfile(fnRs[1:4])

#Run the Plot Quality of the forward reads for four samples 
plotQualityProfile(fnFs[1:4])

# Place filtered files in filtered subdirectory
filtFs <- file.path(path, "filtered", paste0(sample.names, "_F_filt.fastq.gz"))
filtRs <- file.path(path, "filtered", paste0(sample.names, "_R_filt.fastq.gz"))
names(filtFs) <- sample.names
names(filtRs) <- sample.names

#Filter and Trim stage now. Will Filter forward reads at 240 and will filter reverse reads at 220
out <- filterAndTrim(fnFs, filtFs, fnRs, filtRs, truncLen=c(240,220),
                     maxN=0, maxEE=c(2,2), truncQ=2, rm.phix=TRUE,
                     compress=TRUE, multithread=FALSE)

#Run the Plot Quality of the forward TruncLen Filtered samples for four samples 
plotQualityProfile(filtFs [1:4])

#Run the Plot Quality of the reverse TruncLen Filtered samples for four samples 
plotQualityProfile(filtRs [1:4])

#Learn the Error Rates Forward 
errF <- learnErrors(filtFs, multithread=TRUE)

#Learn the Error Rates Reverse 
errR <- learnErrors(filtRs, multithread=TRUE)

#Check the estimated error rates in the forward reads 
plotErrors(errF, nominalQ=TRUE)

#check the estimated error rates in the reverse reads 
plotErrors(errR, nominalQ=TRUE)

#get a list of the files that still exist after filtering 
exists <- file.exists(filtFs)

#Dereplicate the existing files in forward
derepFs <- derepFastq(filtFs[exists], verbose=TRUE)

#Dereplicating the existing files in reverse
derepRs <- derepFastq(filtRs[exists], verbose=TRUE)

# Name the derep-class objects by the sample names
names(derepFs) <- sample.names[exists]
names(derepRs) <- sample.names[exists]

#Sample Inference of the derep forward samples no pooling 
dadaFs <- dada(derepFs, err=errF, multithread=TRUE)

#Sample Inference of the derep reverse samples no pooling 
dadaRs <- dada(derepRs, err=errR, multithread=TRUE)

#inspecting the dada-class object
dadaFs[[1]]

#Merge paired reads 
mergers <- mergePairs(dadaFs, derepFs, dadaRs, derepRs, verbose=TRUE)

# Inspect the merger data.frame from the first sample
head(mergers[[1]])# Inspect the merger data.frame from the first sample
head(mergers[[1]])

#construct an ASV sequence table 
seqtab <- makeSequenceTable(mergers)
dim(seqtab)

# Inspect distribution of sequence lengths
table(nchar(getSequences(seqtab)))

# Remove chimeras
seqtab.nochim <- removeBimeraDenovo(seqtab, method="consensus", multithread=TRUE, verbose=TRUE)
dim(seqtab.nochim)

# Determine the frequency of chimeras 
sum(seqtab.nochim)/sum(seqtab)
# .92, so they count for about about 8% of merged sequence reads 

# Track reads through the pipeline and make sure they made it thru the pipeline
getN <- function(x) sum(getUniques(x))
track <- cbind(out, sapply(dadaFs, getN), sapply(dadaRs, getN), sapply(mergers, getN), rowSums(seqtab.nochim))
# If processing a single sample, remove the sapply calls: e.g. replace sapply(dadaFs, getN) with getN(dadaFs)
colnames(track) <- c("input", "filtered", "denoisedF", "denoisedR", "merged", "nonchim")
rownames(track) <- sample.names

#make a table in TSV form
write.table(track, "read-count-tracking.tsv", quote=FALSE, sep="\t", col.names=NA)

#loading reference taxonomy object
load("SILVA_SSU_r138_2019.RData")

#loading DECIPHER
library(DECIPHER)

#assign taxonomy
taxa <- assignTaxonomy(seqtab.nochim, "silva_nr99_v138.1_train_set.fa.gz", multithread=TRUE)

taxa.print <- taxa # Removing sequence rownames for display only
rownames(taxa.print) <- NULL
head(taxa.print)

#construct a data.frame 
samples.out <- rownames(seqtab.nochim)
subject <- sapply(strsplit(samples.out, "D"), `[`, 1)
samdf <- data.frame(Subject=subject)
rownames(samdf) <- samples.out

#construct a phyloseq object 
ps <- phyloseq(otu_table(seqtab.nochim, taxa_are_rows=FALSE), 
               sample_data(samdf), 
               tax_table(taxa))
ps <- prune_samples(sample_names(ps) != "Mock", ps) # Remove mock sample
ps <- prune_samples(sample_names(ps) != "Mock", ps) # Remove mock sample

#making short ASVs from full DNA sequence 
dna <- Biostrings::DNAStringSet(taxa_names(ps))
names(dna) <- taxa_names(ps)
ps <- merge_phyloseq(ps, dna)
taxa_names(ps) <- paste0("ASV", seq(ntaxa(ps)))
ps
